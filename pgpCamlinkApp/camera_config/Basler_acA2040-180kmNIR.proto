#
# Basler acA2040-180kmNIR protocol
# This should also work for other Basler Ace cameras
#
# Messages start w/ SOH and end w/ ETX
# SOH is the ^A character, 0x01
# ETX is the ^C character, 0x03
#
# Successful replies start w/ an ACK, hex 0x06, followed by reply content, if any
# Unsuccesful commands reply w/ a NAK, hex 0x15
#

## Basler Binary Frame Start and End values
BFS = 0x01;  # SOH
BFE = 0x03;  # ETX

## Basler FTF field
#FTF_RD  = 0x08;
#FTF_WR  = 0x00;
#FTF_CRC = 0x04;
#FTF_A16 = 0x00;
#FTF_A32 = 0x01;
#FTF_A48 = 0x02;
#FTF_A64 = 0x03;
FTF_RD_A32 = 0x0D;
FTF_WR_A32 = 0x05;
FTF_RD_A0  = 0x14;

outTerminator = $BFE;
inTerminator  = "";  # Any inTerminator value may appear in the data, so
                     # specify it explicitly in the 'in' protocols
#PeekSize		   = 0;
ReplyTimeout	= 500;
ReadTimeout		= 500;
WriteTimeout	= 500;
ExtraInput		= Ignore;

# Output: BFS, FTF, Datalen, Address32, BCC, (BFE)
# BFS:		0x01
# FTF:		0x0D	FTF_RD | FTF_A32
# Datalen:	0x04
# Addr:		4 byte little endian
# Bcc:		xor sum
# BFE:		0x03
#
# Input: ACK, BFS, FTF, Datalen, Data, BCC, BFE
# ACK:		0x06
# BFS:		0x01
# FTF:		0x14	FTF_RD_A0
# Datalen:	0x04
# Data:		4 byte little endian
# Bcc:		xor sum
# BFE:		0x03
GetUInt32
{
	out $BFS $FTF_RD_A32 0x04 "\$4\$3\$2\$1" "%1.0<xor>";
	in  ACK $BFS $FTF_RD_A0 0x04 "%#04r" "%2.0<xor>" $BFE;
}

# Output: BFS, FTF, Datalen, Address32, BCC, (BFE)
# BFS:		0x01
# FTF:		0x05	FTF_WR | FTF_A32
# Datalen:	0x04
# Addr:		4 byte little endian
# Data:		4 byte little endian
# Bcc:		xor sum
# BFE:		0x03
#
# Input: ACK
# ACK:		0x06
SetUInt32
{
	out $BFS $FTF_WR_A32 0x04 "\$4\$3\$2\$1" "%#0.4r" "%1.0<xor>";
	in  ACK;
}

# Output: BFS, FTF, Datalen, Address32, BCC, (BFE)
# BFS:		0x01
# FTF:		0x0D	FTF_RD | FTF_A32
# Datalen:	0x08
# Addr:		4 byte little endian
# Bcc:		xor sum
# BFE:		0x03
#
# Input: ACK, BFS, FTF, Datalen, Data, BCC, BFE
# ACK:		0x06
# BFS:		0x01
# FTF:		0x14	FTF_RD_A0
# Datalen:	0x08
# Data:		8 byte little endian
# Bcc:		xor sum
# BFE:		0x03
GetUInt64
{
	out $BFS $FTF_RD_A32 0x08 "\$4\$3\$2\$1" "%1.0<xor>";
	in  ACK $BFS $FTF_RD_A0 0x08 "%#08r" "%2.0<xor>" $BFE;
}

SetUInt64
{
	out $BFS $FTF_WR_A32 0x08 "\$4\$3\$2\$1" "%#0.8r" "%1.0<xor>";
	in  ACK;
}

GetString
{
	out $BFS $FTF_RD_A32 "\$5" "\$4\$3\$2\$1" "%1.0<xor>";
	in  ACK $BFS $FTF_RD_A0 "\$5" "%!32s" "%2.0<xor>" $BFE;
}

GetString2
{
	out $BFS $FTF_RD_A32 "\$5" "\$4\$3\$2\$1" "%1.0<xor>";
	in  ACK $BFS $FTF_RD_A0 "\$5" "%!236s" "%2.0<xor>" $BFE;
}

SetString
{
	out $BFS $FTF_WR_A32 "\$5" "\$4\$3\$2\$1" "%32c" "%1.0<xor>";
	in  ACK;
}

GetTest
{
	out $BFS $FTF_RD_A32 0x04 "%(\$1BaslerTestAdx)#0.4r" "%1.0<xor>";
	in  ACK $BFS $FTF_RD_A0 0x04 "%#04r" "%2.0<xor>" $BFE;
}

SetTest
{
	out $BFS $FTF_WR_A32 0x04 "%(\$1BaslerTestAdx)#0.4r" "%#0.4r" "%1.0<xor>";
	in  ACK;
}
