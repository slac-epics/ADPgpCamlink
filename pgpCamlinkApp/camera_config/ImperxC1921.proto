#
# Imperx Serial Protocol
#
# Read Operation:
#	Send 3 Bytes:
#		Byte 1:	0x52
#		Byte 2:	Addr MSB
#		Byte 3:	Addr LSB
#
#	Expect to Receive:
#		Byte 1:	0x06 (ACK)
#		Byte 2:	Data Byte 4 (MSB)
#		Byte 3:	Data Byte 3
#		Byte 4:	Data Byte 2
#		Byte 5:	Data Byte 1 (LSB)
#
# Write Operation:
#	Send 7 bytes:
#		Byte 1:	0x57
#		Byte 2:	Addr MSB
#		Byte 3:	Addr LSB
#		Byte 4:	Data Byte 4 (MSB)
#		Byte 5:	Data Byte 3
#		Byte 6:	Data Byte 2
#		Byte 7:	Data Byte 1 (LSB)
#
# Successful replies start w/ an ACK, hex 0x06, followed by reply content, if any
# Unsuccesful commands reply w/ a NAK, hex 0x15, followed by a one byte error code
#	Error Codes:
#	0x00 No error
#	0x01 Invalid command. An invalid command (not 52 or 57) sent to the camera.
#	0x02 Time-out
#	0x03 Checksum error
#	0x04 Value less than minimum
#	0x05 Value higher than maximum
#	0x06 AGC error
#	0x07 Supervisor mode error
#	0x08 Mode not supported error

#
inTerminator	= "";
outTerminator	= "";
#PeekSize		= 0;
ReplyTimeout	= 800;
ReadTimeout 	= 300;
#WriteTimeout	= 500;
#ExtraInput		= Ignore;

# Imperx C1921 Register Addresses
# Composed of 2 bytes, LSB then MSB of register address
# Composed of 2 bytes, MSB then LSB of register address
AnalogGain		= \x00\x00;	# 0dB to 24dB
A2D_Bits		= \x00\x08;	# 0x0 = 8 bits, 0x1 = 10 bits, 0x2  = 12 bits
# Area Of Interest (AOI), same as ROI
AOI_Mode		= \x00\x10;	# 0 = MAOI disable, 1 = MAOI w/ FrameRate increase, 2 = MAOI w/ constant FR
AOI_HorizOffset	= \x00\x14;	# HW ROI, MinX
AOI_HorizSize	= \x00\x18;	# HW ROI, SizeX
AOI_VertOffset	= \x00\x1C;	# HW ROI, MinY
AOI_VertSize	= \x00\x20;	# HW ROI, SizeY
HorizDecimate	= \x00\x24;	# 0 = Horiz 2:1 Decimation disabled, 1 = enabled
VertDecimate	= \x00\x28;	# 0 = Vert  2:1 Decimation disabled, 1 = enabled
VertBinning		= \x00\x2C;	# 0 = Vert  2X  Binning    disabled, 1 = enabled
ImageHorizFlip	= \x00\x30;	# 0 = Horiz Flip disabled, 1 = enabled
ImageVertFlip	= \x00\x34;	# 0 = Vert  Flip disabled, 1 = enabled
BlkLevelEnable	= \x00\x38;	# 0 = Black Level Correction disabled, 1 = enabled
BlkLevel		= \x00\x3C;	# 0 to ?
ExpCtrlMode		= \x00\x40;	# 0 = None, 1 = Trigger Pulse Width, 2 = Internal Fixed Rate
ExpDuration		= \x00\x44;	# Exposure time in micro seconds
DataOutputBits	= \x01\x00;	# Bit_Dpt_Sel 0x0 = 8 bits, 0x1 = 10 bits, 0x2  = 12 bits
CamlinkMode		= \x01\x04;	# Dat_Fmt_Sel 0x0 = Base (2 taps), 0x1 = Base (3 taps), 0x2 = Medium, 0x3 = Full, 0x4 = DECA
TestPattern		= \x01\x08;	# 0=None, 1=Checkerbd, 2=Gray, 3=TapValues, 4=HRamp, 5=VRamp, 6=BothRamp, 7=Moving,8=Bars, 9=Cross
HorizBinning	= \x01\x10;	# 0 = Horiz 2X  Binning    disabled, 1 = enabled
DigitalOffset	= \x01\x5C;	# -511 to +512
DigitalGain		= \x01\x60; # 0dB to 24dB
TrigEnable		= \x05\x00;	# 0 = Trigger mode disabled, 1 = enabled
TrigInput		= \x05\x04;	# 0 = N/A, 1 = Ext Cam IN1, 2 = Internal, 3 = Camlink CC1, 4 = SW Trigger, 5 = Ext Cam IN2
TrigEdgeSelect	= \x05\x08;	# 0 = Rising Edge 1 = Falling Edge
TrigDebounce	= \x05\x0C;	# Trigger debounce time in micro sec
TrigFilterTime	= \x05\x10;	# Trigger filter time in micro sec.  Shorter pulses are ignored.
TrigOverlapMode	= \x05\x14;	# 0 = Ignore extra trigger, 1 = Abort prior capture and retrigger
TrigModeSelect	= \x05\x18;	# 0 = Std trigger, 1 = Fast triggering
FramesPerTrigger= \x05\x1C;	# Number of frames to capture per trigger
TrigExpDelay	= \x05\x20;	# Delay in micro sec between trigger and start of exposure
TrigStrobeMode	= \x05\x24;	# 0 = Trig Strobe disabled, 1 = enable Strobe #1, 2 = enable Strobe #2, 3 = enable #1 and #2
FirmwareVer		= \x60\x06;	# Bits FirmwareVers=0:23, CMOScolor=24:27, FirmwareImage=28:31=
SerialOK		= \x60\x0C;	# Bits Temp=246.312-(D(9:0)*0.304)
CamTemp			= \x60\x10;	# Bits Temp=246.312-(D(9:0)*0.304)
SoftReset		= \x60\x1C;	# Write 0xDEADBEEF to reset camera
SWTrigger		= \x60\x30;	# Software Trigger command
CamFrameTime	= \x60\x80; # Returns current camera frame time in microseconds
MinFrameTime	= \x60\x84; # Returns current minimum frame time in microseconds

# Read Operation
# Send 3 bytes to camera
#	0x52	(R)
#	MSB_Addr
#	LSB_Addr
#
#	Camera always returns ACK and 4 bytes
#	If address is invalid, the 4 bytes are zeroes.
#	0x06	(ACK)
#	MSB
#	...
#	...
#	LSB

SetUint32
{
    out "\x57" "%.2r\$1" "%.4r\$2";    in  "\x06" "@\"%4r";
}

GetUint32
{
#    out "\x52\$TrigEnable";		# Works!
    out "\x52\$1";
#    out "\x52%1(\$1)r%1(\$2)r";
	in  "\x06%04r";
#   @init { out "\x52" "%.2r\$1";    in  "\x06" "%.4r"; }
}

GetTrigEnable
{
    out "\x52\$TrigEnable";
	in  "\x06%04r";
}
SetTrigEnable
{
    out "\x57\$TrigEnable" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigInput
{
    out "\x52\$TrigInput";
	in  "\x06%04r";
}
SetTrigInput
{
    out "\x57\$TrigInput" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigEdgeSelect
{
    out "\x52\$TrigEdgeSelect";
	in  "\x06%04r";
}
SetTrigEdgeSelect
{
    out "\x57\$TrigEdgeSelect" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetExpCtrlMode
{
    out "\x52\$ExpCtrlMode";
	in  "\x06%04r";
}
SetExpCtrlMode
{
    out "\x57\$ExpCtrlMode" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetA2D_Bits
{
    out "\x52\$A2D_Bits";
	in  "\x06%04r";
}
SetA2D_Bits
{
    out "\x57\$A2D_Bits" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetDataOutputBits
{
    out "\x52\$DataOutputBits";
	in  "\x06%04r";
}
SetDataOutputBits
{
    out "\x57\$DataOutputBits" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetCamlinkMode
{
    out "\x52\$CamlinkMode";
	in  "\x06%04r";
}
SetCamlinkMode
{
    out "\x57\$CamlinkMode" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigDebounce
{
    out "\x52\$TrigDebounce";
	in  "\x06%04r";
}
SetTrigDebounce
{
    out "\x57\$TrigDebounce" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigFilterTime
{
    out "\x52\$TrigFilterTime";
	in  "\x06%04r";
}
SetTrigFilterTime
{
    out "\x57\$TrigFilterTime" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigOverlapMode
{
    out "\x52\$TrigOverlapMode";
	in  "\x06%04r";
}
SetTrigOverlapMode
{
    out "\x57\$TrigOverlapMode" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetFramesPerTrigger
{
    out "\x52\$FramesPerTrigger";
	in  "\x06%04r";
}
SetFramesPerTrigger
{
    out "\x57\$FramesPerTrigger" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigExpDelay
{
    out "\x52\$TrigExpDelay";
	in  "\x06%04r";
}
SetTrigExpDelay
{
    out "\x57\$TrigExpDelay" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigModeSelect
{
    out "\x52\$TrigModeSelect";
	in  "\x06%04r";
}
SetTrigModeSelect
{
    out "\x57\$TrigModeSelect" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTrigStrobeMode
{
    out "\x52\$TrigStrobeMode";
	in  "\x06%04r";
}
SetTrigStrobeMode
{
    out "\x57\$TrigStrobeMode" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetAOI_Mode
{
    out "\x52\$AOI_Mode";
	in  "\x06%04r";
}
SetAOI_Mode
{
    out "\x57\$AOI_Mode" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetAOI_HorizOffset
{
    out "\x52\$AOI_HorizOffset";
	in  "\x06%04r";
}
SetAOI_HorizOffset
{
    out "\x57\$AOI_HorizOffset" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetAOI_HorizSize
{
    out "\x52\$AOI_HorizSize";
	in  "\x06%04r";
}
SetAOI_HorizSize
{
    out "\x57\$AOI_HorizSize" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetAOI_VertOffset
{
    out "\x52\$AOI_VertOffset";
	in  "\x06%04r";
}
SetAOI_VertOffset
{
    out "\x57\$AOI_VertOffset" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetAOI_VertSize
{
    out "\x52\$AOI_VertSize";
	in  "\x06%04r";
}
SetAOI_VertSize
{
    out "\x57\$AOI_VertSize" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetHorizDecimate
{
    out "\x52\$HorizDecimate";
	in  "\x06%04r";
}
SetHorizDecimate
{
    out "\x57\$HorizDecimate" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetVertDecimate
{
    out "\x52\$VertDecimate";
	in  "\x06%04r";
}
SetVertDecimate
{
    out "\x57\$VertDecimate" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetVertBinning
{
    out "\x52\$VertBinning";
	in  "\x06%04r";
}
SetVertBinning
{
    out "\x57\$VertBinning" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetHorizBinning
{
    out "\x52\$HorizBinning";
	in  "\x06%04r";
}
SetHorizBinning
{
    out "\x57\$HorizBinning" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetTestPattern
{
    out "\x52\$TestPattern";
	in  "\x06%04r";
}
SetTestPattern
{
    out "\x57\$TestPattern" "%04.4r";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}
SoftReset
{
    out "\x57\$SoftReset" "\xDE\xAD\xBE\xEF";
	in  "\x06";
    @mismatch { in  "\x15" "%(\$1ImperxCommError)1r"; }
}

GetCamFrameTime
{
    out "\x52\$CamFrameTime";
	in  "\x06%04r";
}
GetMinFrameTime
{
    out "\x52\$MinFrameTime";
	in  "\x06%04r";
}
