#
# EPICS database for
# Basler acA2040-25gmNIR
#
# Protocol root must match db filename root
# i.e. Basler.proto

record( seq, "$(P)$(R)ReConfigSeq" )
{
#	field( DLY0, "0.0" ) field( DOL0, "1" ) field( LNK0, "$(P)$(R)BaslerAccessPrivilege.PROC CA NMS" )
#	field( DLY1, "0.1" ) field( DOL1, "1" ) field( LNK1, "$(P)$(R)BaslerExposureValue_RBV.PROC CA NMS" )
#	field( DLY2, "0.1" ) field( DOL2, "1" ) field( LNK2, "$(P)$(R)BaslerAcqStartFullTrMode_RBV.PROC CA NMS" )
#	field( DLY3, "0.1" ) field( DOL3, "1" ) field( LNK3, "$(P)$(R)BaslerAcqStopFullTrMode_RBV.PROC CA NMS" )
#	field( DLY5, "0.1" ) field( DOL5, "0" ) field( LNK0, "$(P)$(R)BaslerFStartFullTrMode_RBV.PROC CA NMS" )
#	field( DLY6, "0.1" ) field( DOL6, "1" ) field( LNK6, "$(P)$(R)BaslerLine1GlitchFilter.PROC CA NMS" )
#	field( DLY7, "0.1" ) field( DOL7, "1" ) field( LNK7, "$(P)$(R)BaslerFStartTrSrc.PROC CA NMS" )
#	field( DLY8, "0.1" ) field( DOL4, "1" ) field( LNK8, "$(P)$(R)BaslerHeartbeatTimeout_RBV.PROC CA NMS" )
	field( TPRO, 1 )
	field( FLNK, "$(P)$(R)ReConfigSeq2" )
}
record( seq, "$(P)$(R)ReConfigSeq2" )
{

#	field( DLY1, "0.1" ) field( DOL1, "1" ) field( LNK1, "$(P)$(R)Model_RBV.PROC CA NMS" )
#	field( DLY2, "0.1" ) field( DOL2, "1" ) field( LNK2, "$(P)$(R)Manufacturer_RBV.PROC CA NMS" )
#	field( DLY3, "0.1" ) field( DOL3, "1" ) field( LNK3, "$(P)$(R)BaslerSerialNumber_RBV.PROC CA NMS" )
#	field( DLY4, "0.1" ) field( DOL4, "1" ) field( LNK4, "$(P)$(R)BaslerFirmwareVersion_RBV.PROC CA NMS" )
#	field( DLY5, "0.0" ) field( DOL5, "1" ) field( LNK5, "$(P)$(R)BaslerModel_RBV.PROC CA NMS" )
#	field( DLY6, "0.1" ) field( DOL6, "1" ) field( LNK6, "$(P)$(R)BaslerTempMainBd_RBV.PROC CA NMS" )
#	field( DLY7, "0.1" ) field( DOL7, "1" ) field( LNK7, "$(P)$(R)BaslerTempSensorBd_RBV.PROC CA NMS" )
#	field( DLY8, "0.1" ) field( DOL8, "1" ) field( LNK8, "$(P)$(R)BaslerTemperature_RBV.PROC CA NMS" )
#	field( FLNK, "$(P)$(R)ReConfigSeq3" )
}

record( stringin, "$(P)$(R)CamModel" )
{
	field( VAL,  "acA2040-180kmNIR" )
	field( PINI, "YES" )
}

record( stringin, "$(P)$(R)CamModelScreen" )
{
	field( VAL,  "ADPgpCamlinkScreens/acA2040.edl" )
	field( PINI, "YES" )
}

# Camlink settings
record( longout, "$(P)$(R)CamlinkPixelClk" )
{
	field( DOL,  "80" )
}

record( longout, "$(P)$(R)CamlinkBaudRate" )
{
	field( DOL,  "9600" )
	field( OMSL, "closed_loop" )
	field( HIGH, "9601" )
	field( HSV,  "MINOR" )
	field( LOW,  "9599" )
	field( LSV,  "MINOR" )
	field( PINI, "YES" )
}
record( mbbo, "$(P)$(R)CamlinkDataMode" )
{
	field( DOL,  "3" )
	field( FRSV, "MINOR" )
	field( TWSV, "MINOR" )
	field( PINI, "YES" )
}
record( mbbo, "$(P)$(R)CamlinkFrameMode" )
{
	field( DOL,  "2" )
	field( THSV, "MINOR" )
	field( ONSV, "MINOR" )
	field( PINI, "YES" )
}
record( mbbo, "$(P)$(R)CamlinkLinkMode" )
{
	field( DOL,  "2" )
	field( THSV, "MINOR" )
	field( ONSV, "MINOR" )
	field( PINI, "YES" )
}
record( longout, "$(P)$(R)CamlinkHTap" )
{
	field( DOL,  "4" )
	field( LOW,  "3" )
	field( LSV,  "MINOR" )
	field( HIGH, "5" )
	field( HSV,  "MINOR" )
	field( PINI, "YES" )
}
record( longout, "$(P)$(R)CamlinkTrigMask" )
{
	field( DOL,  "1" )
	field( OMSL, "closed_loop" )
	field( PINI, "YES" )
}
record( bo, "$(P)$(R)CamlinkInvCC" )
{
	field( DOL,  "1" )
	field( PINI, "YES" )
}

# Provide defaults for ADCore SizeX and SizeY
record( longout, "$(P)$(R)SizeX" )
{
	field( VAL, "2048" )
}
record( longout, "$(P)$(R)SizeY" )
{
	field( VAL, "2048" )
}
record( longout, "$(P)$(R)CamlinkHActive" )
{
	field( VAL, "2048" )
}
record( longout, "$(P)$(R)CamlinkVActive" )
{
	field( VAL, "2048" )
}

# Debugging:
record( longout, "$(P)$(R)BaslerTestAdx" )
{
	field( VAL, "0" )
	field( FLNK, "$(P)$(R)BaslerTestValue_RBV" )
	field( SCAN, "Passive" )
}
record( longout, "$(P)$(R)BaslerTestValue" )
{
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetTest($(P)$(R)) $(PORT).SER" )
	field( FLNK, "$(P)$(R)BaslerTestValue_RBV" )
	field( SCAN, "Passive" )
}
record( longin, "$(P)$(R)BaslerTestValue_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetTest($(P)$(R)) $(PORT).SER" )
}


# 4.1 Device Information Registers

# Update fields for ADCore records that we get via GenCP
record( stringin, "$(P)$(R)Manufacturer_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetString(\\x00,\\x00,\\x01,\\x08, \\x20) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

# Update fields for ADCore records that we get via GenCP
record( stringin, "$(P)$(R)Model_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetString(\\x00,\\x00,\\x02,\\x08, \\x20) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( stringin, "$(P)$(R)BaslerFirmwareVersion_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetString2(\\x00,\\x00,\\x03,\\x08, \\xec) $(PORT).SER" )
#	field( INP,  "@Basler.proto GetString(\\x00,\\x00,\\x03,\\x08, \\x20) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( stringin, "$(P)$(R)BaslerVersion_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetString(\\x00,\\x00,\\x04,\\x08, \\x20) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( stringin, "$(P)$(R)BaslerSerialNumber_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetString(\\x00,\\x00,\\x05,\\x08, \\x20) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( stringin, "$(P)$(R)BaslerModel_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetString(\\x00,\\x00,\\x05,\\x88, \\x20) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( stringin, "$(P)$(R)BaslerUserID_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetString(\\x00,\\x01,\\x20,\\x08, \\x20) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( stringout, "$(P)$(R)BaslerUserID" )
{
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetString(\\x00,\\x01,\\x20,\\x08, \\x20) $(PORT).SER" )
	field( FLNK, "$(P)$(R)BaslerUserID_RBV" )
#	field( TPRO, 2 )
}

# Not implemented
record( longin, "$(P)$(R)BaslerTempSensorBd_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x10,\\x08) $(PORT).SER" )
	field( EGU,  "C" )
	field( HIHI, "60" )   field( HHSV, "MAJOR" )
	field( HIGH, "50" )   field( HSV,  "MINOR" )
#	field( SCAN, "10 second" )
	field( PINI, "YES" )
}

# Not implemented
record( longin, "$(P)$(R)BaslerTempMainBd_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x10,\\x28) $(PORT).SER" )
	field( EGU,  "C" )
	field( HIHI, "60" )   field( HHSV, "MAJOR" )
	field( HIGH, "50" )   field( HSV,  "MINOR" )
#	field( SCAN, "10 second" )
	field( PINI, "YES" )
}

# Not implemented
record( longin, "$(P)$(R)BaslerTemperature_RBV" )
{
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x10,\\x68) $(PORT).SER" )
	field( EGU,  "C" )
	field( HIHI, "60" )   field( HHSV, "MAJOR" )
	field( HIGH, "50" )   field( HSV,  "MINOR" )
#	field( SCAN, "10 second" )
	field( PINI, "YES" )
}

# Not implemented
record( bi, "$(P)$(R)BaslerOverTemp_RBV" )
{
	field( DESC, "Over Temperature" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x11,\\x08) $(PORT).SER" )
#	field( SCAN, "10 second" )
}

# Not implemented
record( bi, "$(P)$(R)BaslerCriticalTemp_RBV" )
{
	field( DESC, "Critical Temperature" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x12,\\x08) $(PORT).SER" )
#	field( SCAN, "10 second" )
}

record( longin, "$(P)$(R)SensorWidth" )
{
	field( DESC, "Sensor Width" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x00,\\x08) $(PORT).SER" )
	field( PINI, "YES" )
}

record( longin, "$(P)$(R)SensorHeight" )
{
	field( DESC, "Sensor Height" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x00,\\x28) $(PORT).SER" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)ScanType" )
{
	field( DESC, "Device Scan Type" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x00,\\x44) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 1 )
	field( ZRST, "Areascan" )   # The imaging sensor is an area scan sensor.
	field( ONST, "Linescan" )   # The imaging sensor is a line scan sensor.
	field( PINI, "YES" )
}

record( bi, "$(P)$(R)RegistersValid" )
{
	field( DESC, "Device Registers Valid" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x00,\\x68) $(PORT).SER" )
	field( ZNAM, "NO" )
	field( ONAM, "YES"  )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)BaslerLastError_RBV" )
{
	field( DESC, "Last User Error" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x01,\\x30,\\x04) $(PORT).SER" )
	field( ZRVL, 0 )  field( ZRST, "No Error" )
	field( ONVL, 1 )  field( ONST, "Overtrigger" )
	field( TWVL, 2 )  field( TWST, "Userset" )
	field( THVL, 3 )  field( THST, "Invalid parameter"   )
#	field( SCAN, "1 second" )
	field( PINI, "YES" )
}

record( bo, "$(P)$(R)BaslerClearLastError" )
{
	field( DESC, "Clear Last User Error" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x01,\\x30,\\x24) $(PORT).SER" )
	field( ZNAM, "Cleared" )
	field( ONAM, "Clear"  )
	field( FLNK, "$(P)$(R)BaslerLastError_RBV" )
}


# 4.2 Transport Layer Registers

record( mbbo, "$(P)$(R)CLBaudRate" )
{
	field( DESC, "CL Serial Port Baud Rate" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x00,\\x07,\\x04) $(PORT).SER" )
	field( DOL,  0 )
	field( ZRVL, 15 )
	field( ONVL, 17 )
	field( TWVL, 18 )
	field( THVL, 19 )
	field( FRVL, 20 )
	field( FVVL, 21 )
	field( SXVL, 22 )
	field( SVVL, 23 )
	field( ZRST, "9600" )    # The rate is 9600 baud.
	field( ONST, "19200" )   # The rate is 19200 baud.
	field( TWST, "38400" )   # The rate is 38400 baud.
	field( THST, "57600" )   # The rate is 57600 baud.
	field( FRST, "115200" )  # The rate is 115200 baud.
	field( FVST, "230400" )  # The rate is 230400 baud.
	field( SXST, "460800" )  # The rate is 460800 baud.
	field( SVST, "921600" )  # The rate is 921600 baud.
	field( FLNK, "$(P)$(R)CLBaudRate_RBV" )
}

record( mbbi, "$(P)$(R)CLBaudRate_RBV" )
{
	field( DESC, "CL Serial Port Baud Rate" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x00,\\x07,\\x04) $(PORT).SER" )
	field( ZRVL, 15 )
	field( ONVL, 17 )
	field( TWVL, 18 )
	field( THVL, 19 )
	field( FRVL, 20 )
	field( FVVL, 21 )
	field( SXVL, 22 )
	field( SVVL, 23 )
	field( ZRST, "9600" )    # The rate is 9600 baud.
	field( ONST, "19200" )   # The rate is 19200 baud.
	field( TWST, "38400" )   # The rate is 38400 baud.
	field( THST, "57600" )   # The rate is 57600 baud.
	field( FRST, "115200" )  # The rate is 115200 baud.
	field( FVST, "230400" )  # The rate is 230400 baud.
	field( SXST, "460800" )  # The rate is 460800 baud.
	field( SVST, "921600" )  # The rate is 921600 baud.
	field( PINI, "YES" )
}

record( mbbo, "$(P)$(R)CLTapGeometry" )
{
	field( DOL,  "4" )
	field( DESC, "The CL Tap Geometry" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x00,\\x07,\\x24) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( TWVL,  6 )
	field( THVL,  7 )
	field( FRVL,  9 )
	field( FVVL, 11 )
	field( SXVL, 12 )
	field( SVVL, 14 )
	field( ZRST, "1X-1Y" )    # The tap geometry is 1X-1Y.
	field( ONST, "1X2-1Y" )   # The tap geometry is 1X2-1Y.
	field( TWST, "1X-2YE" )   # The tap geometry is 1X-2YE.
	field( THST, "1X3-1Y" )   # The tap geometry is 1X3-1Y.
	field( FRST, "1X4-1Y" )   # The tap geometry is 1X4-1Y.
	field( FVST, "1X6-1Y" )   # The tap geometry is 1X6-1Y.
	field( SXST, "1X8-1Y" )   # The tap geometry is 1X8-1Y.
	field( SVST, "1X10-1Y" )  # The tap geometry is 1X10-1Y.
	field( FLNK, "$(P)$(R)CLTapGeometry_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)CLTapGeometry_RBV" )
{
	field( DESC, "The CL Tap Geometry readback value" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x00,\\x07,\\x24) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( TWVL,  6 )
	field( THVL,  7 )
	field( FRVL,  9 )
	field( FVVL, 11 )
	field( SXVL, 12 )
	field( SVVL, 14 )
	field( ZRST, "1X-1Y" )    # The tap geometry is 1X-1Y.
	field( ONST, "1X2-1Y" )   # The tap geometry is 1X2-1Y.
	field( TWST, "1X-2YE" )   # The tap geometry is 1X-2YE.
	field( THST, "1X3-1Y" )   # The tap geometry is 1X3-1Y.
	field( FRST, "1X4-1Y" )   # The tap geometry is 1X4-1Y.
	field( FVST, "1X6-1Y" )   # The tap geometry is 1X6-1Y.
	field( SXST, "1X8-1Y" )   # The tap geometry is 1X8-1Y.
	field( SVST, "1X10-1Y" )  # The tap geometry is 1X10-1Y.
#	field( PINI, "YES" )
}

record( mbbo, "$(P)$(R)CLPixelClock" )
{
	field( DOL,  "5" )
	field( DESC, "Camlink Pixel Clock" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x00,\\x07,\\x44) $(PORT).SER" )
	field( ZRVL,  1 )
	field( ONVL,  4 )
	field( TWVL,  6 )
	field( THVL, 10 )
	field( FRVL, 16 )
	field( FVVL, 23 )
	field( SXVL, 24 )
	field( SVVL, 27 )
	field( ZRST, "20 MHz" )    # The pixel clock speed is 20 MHz.
	field( ONST, "32.5 MHz" )  # The pixel clock speed is 32.5 MHz.
	field( TWST, "40 MHz" )    # The pixel clock speed is 40 MHz.
	field( THST, "48 MHz" )    # The pixel clock speed is 48 MHz.
	field( FRST, "65 MHz" )    # The pixel clock speed is 65 MHz.
	field( FVST, "82 MHz" )    # The pixel clock speed is 82 MHz.
	field( SXST, "82.5 MHz" )  # The pixel clock speed is 82.5 MHz.
	field( SVST, "84 MHz" )    # The pixel clock speed is 84 MHz.
	field( FLNK, "$(P)$(R)CLPixelClock_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)CLPixelClock_RBV" )
{
	field( DESC, "The CL Pixel Clock readback value" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x00,\\x07,\\x44) $(PORT).SER" )
	field( ZRVL,  1 )
	field( ONVL,  4 )
	field( TWVL,  6 )
	field( THVL, 10 )
	field( FRVL, 16 )
	field( FVVL, 23 )
	field( SXVL, 24 )
	field( SVVL, 27 )
	field( ZRST, "20 MHz" )    # The pixel clock speed is 20 MHz.
	field( ONST, "32.5 MHz" )  # The pixel clock speed is 32.5 MHz.
	field( TWST, "40 MHz" )    # The pixel clock speed is 40 MHz.
	field( THST, "48 MHz" )    # The pixel clock speed is 48 MHz.
	field( FRST, "65 MHz" )    # The pixel clock speed is 65 MHz.
	field( FVST, "82 MHz" )    # The pixel clock speed is 82 MHz.
	field( SXST, "82.5 MHz" )  # The pixel clock speed is 82.5 MHz.
	field( SVST, "84 MHz" )    # The pixel clock speed is 84 MHz.
}

# Not implemented:
record( longout, "$(P)$(R)CLInterlineDelay" )
{
	field( DESC, "CL Interline Delay" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x00,\\x07,\\x64) $(PORT).SER" )
# Disabled to avoid accidental use
	field( DISV, "0" )
}

record( mbbo, "$(P)$(R)BaslerCLConfig" )
{
	field( DOL,  "1" )
	field( DESC, "Camera Link configuration" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto GetUInt32(\\x00,\\x00,\\x07,\\x84) $(PORT).SER" )
	field( ZRVL, 1 )
	field( ONVL, 2 )
	field( TWVL, 3 )
	field( THVL, 4 )
	field( FRVL, 5 )
	field( ZRST, "Base" )      # The camera will use the base Camera Link configuration.
	field( ONST, "Medium" )    # The camera will use the medium Camera Link configuration.
	field( TWST, "Full" )      # The camera will use the full Camera Link configuration.
	field( THST, "DualBase" )  # The camera will use the dual base Camera Link configuration.
	field( FRST, "Deca" )      # The camera will use the deca Camera Link configuration.
	field( FLNK, "$(P)$(R)BaslerCLConfig_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)BaslerCLConfig_RBV" )
{
	field( DESC, "Camera Link configuration" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x00,\\x07,\\x84) $(PORT).SER" )
	field( ZRVL, 1 )
	field( ONVL, 2 )
	field( TWVL, 3 )
	field( THVL, 4 )
	field( FRVL, 5 )
	field( ZRST, "Base" )      # The camera will use the base Camera Link configuration.
	field( ONST, "Medium" )    # The camera will use the medium Camera Link configuration.
	field( TWST, "Full" )      # The camera will use the full Camera Link configuration.
	field( THST, "DualBase" )  # The camera will use the dual base Camera Link configuration.
	field( FRST, "Deca" )      # The camera will use the deca Camera Link configuration.
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}


# 4.3 Analog Control Registers

# 4.4 Image Format Registers

# Not implemented
record( mbbo, "$(P)$(R)SensorDigitizationTaps" )
{
#	field( DOL,  "0" )
	field( DESC, "Sensor Digitization Taps" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x03,\\x00,\\x04) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 3 )
	field( ZRST, "One" )   # One tap is used to read pixel data out of the imaging sensor.
	field( ONST, "Four" )  # Four taps are used to read pixel data out of the imaging sensor.
	field( FLNK, "$(P)$(R)SensorDigitizationTaps_RBV" )
# Disabled to avoid accidental use
#	field( DISV, "0" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)SensorDigitizationTaps_RBV" )
{
	field( DESC, "Sensor Digitization Taps" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x03,\\x00,\\x04) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 3 )
	field( ZRST, "One" )   # One tap is used to read pixel data out of the imaging sensor.
	field( ONST, "Four" )  # Four taps are used to read pixel data out of the imaging sensor.
}

# SensorBitDepth: Base address 0x30500, manual pg 44
record( mbbo, "$(P)$(R)BaslerBitsPerPixel" )
{
	field( DOL,  "2" )
	field( DESC, "Sets the bit depth of the pixel data" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x03,\\x05,\\x04) $(PORT).SER" )
	field( ZRVL,  8 )
	field( ONVL, 10 )
	field( TWVL, 12 )
	field( THVL, 14 )
	field( FRVL, 16 )
	field( ZRST, "8" )   # The sensor will produce pixel data at  8 bit depth per pixel.
	field( ONST, "10" )  # The sensor will produce pixel data at 10 bit depth per pixel.
	field( TWST, "12" )  # The sensor will produce pixel data at 12 bit depth per pixel.
	field( THST, "14" )  # The sensor will produce pixel data at 14 bit depth per pixel.
	field( FRST, "16" )  # The sensor will produce pixel data at 16 bit depth per pixel.
	field( FLNK, "$(P)$(R)BaslerBitsPerPixel_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
## Disabled to avoid accidental use
#	field( DISV, "0" )
}

record( mbbi, "$(P)$(R)BaslerBitsPerPixel_RBV" )
{
	field( DESC, "The bit depth of the pixel data" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x03,\\x05,\\x04) $(PORT).SER" )
	field( ZRVL,  8 )
	field( ONVL, 10 )
	field( TWVL, 12 )
	field( THVL, 14 )
	field( FRVL, 16 )
	field( ZRST, "8" )   # The sensor will produce pixel data at  8 bit depth per pixel.
	field( ONST, "10" )  # The sensor will produce pixel data at 10 bit depth per pixel.
	field( TWST, "12" )  # The sensor will produce pixel data at 12 bit depth per pixel.
	field( THST, "14" )  # The sensor will produce pixel data at 14 bit depth per pixel.
	field( FRST, "16" )  # The sensor will produce pixel data at 16 bit depth per pixel.
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}

record( mbbo, "$(P)$(R)PixelFormat" )
{
	field( DOL,  "2" )
	field( PINI, "YES" )
	field( DESC, "Pixel Format" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt64(\\x00,\\x03,\\x00,\\x24) $(PORT).SER" )
	field( ZRVL,  1 )
	field( ONVL,  3 )
	field( TWVL,  5 )
	field( THVL, 10 )
	field( FRVL, 11 )
	field( FVVL, 12 )
	field( SXVL, 13 )
	field( SVVL, 14 )
	field( EIVL, 15 )
	field( NIVL, 16 )
	field( TEVL, 17 )
	field( ELVL, 18 )
	field( TVVL, 20 )
	field( TTVL, 22 )
	field( FTVL, 24 )
	field( ZRST, "Mono8" )      # The pixel format is Mono 8.
	field( ONST, "Mono10" )     # The pixel format is Mono 10.
	field( TWST, "Mono12" )     # The pixel format is Mono 12.
	field( THST, "BayerGR8" )   # The pixel format is Bayer GR 8.
	field( FRST, "BayerRG8" )   # The pixel format is Bayer RG 8.
	field( FVST, "BayerGB8" )   # The pixel format is Bayer GB 8.
	field( SXST, "BayerBG8" )   # The pixel format is Bayer BG 8.
	field( SVST, "BayerGR10" )  # The pixel format is Bayer GR 10.
	field( EIST, "BayerRG10" )  # The pixel format is Bayer RG 10.
	field( NIST, "BayerGB10" )  # The pixel format is Bayer GB 10.
	field( TEST, "BayerBG10" )  # The pixel format is Bayer BG 10.
	field( ELST, "BayerGR12" )  # The pixel format is Bayer GR 12.
	field( TVST, "BayerRG12" )  # The pixel format is Bayer RG 12.
	field( TTST, "BayerGB12" )  # The pixel format is Bayer GB 12.
	field( FTST, "BayerBG12" )  # The pixel format is Bayer BG 12.
	field( FLNK, "$(P)$(R)PixelFormat_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)PixelFormat_RBV" )
{
	field( DESC, "Pixel Format readback value" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt64(\\x00,\\x03,\\x00,\\x24) $(PORT).SER" )
	field( ZRVL,  1 )
	field( ONVL,  3 )
	field( TWVL,  5 )
	field( THVL, 10 )
	field( FRVL, 11 )
	field( FVVL, 12 )
	field( SXVL, 13 )
	field( SVVL, 14 )
	field( EIVL, 15 )
	field( NIVL, 16 )
	field( TEVL, 17 )
	field( ELVL, 18 )
	field( TVVL, 20 )
	field( TTVL, 22 )
	field( FTVL, 24 )
	field( ZRST, "Mono8" )      # The pixel format is Mono 8.
	field( ONST, "Mono10" )     # The pixel format is Mono 10.
	field( TWST, "Mono12" )     # The pixel format is Mono 12.
	field( THST, "BayerGR8" )   # The pixel format is Bayer GR 8.
	field( FRST, "BayerRG8" )   # The pixel format is Bayer RG 8.
	field( FVST, "BayerGB8" )   # The pixel format is Bayer GB 8.
	field( SXST, "BayerBG8" )   # The pixel format is Bayer BG 8.
	field( SVST, "BayerGR10" )  # The pixel format is Bayer GR 10.
	field( EIST, "BayerRG10" )  # The pixel format is Bayer RG 10.
	field( NIST, "BayerGB10" )  # The pixel format is Bayer GB 10.
	field( TEST, "BayerBG10" )  # The pixel format is Bayer BG 10.
	field( ELST, "BayerGR12" )  # The pixel format is Bayer GR 12.
	field( TVST, "BayerRG12" )  # The pixel format is Bayer RG 12.
	field( TTST, "BayerGB12" )  # The pixel format is Bayer GB 12.
	field( FTST, "BayerBG12" )  # The pixel format is Bayer BG 12.
#	field( PINI, "YES" )
}

# This value must always be in agreement with the Pixel Format value.
record( mbbo, "$(P)$(R)PixelSize" )
{
	field( DOL,  "5" )
	field( DESC, "Pixel Size" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt64(\\x00,\\x03,\\x00,\\xA4) $(PORT).SER" )
	field( ZRVL,  1 )
	field( ONVL,  2 )
	field( TWVL,  4 )
	field( THVL,  8 )
	field( FRVL, 10 )
	field( FVVL, 12 )
	field( SXVL, 16 )
	field( SVVL, 24 )
	field( EIVL, 36 )
	field( NIVL, 48 )
	field( ZRST, "1" )   # The pixel size is 1 bit per pixel.
	field( ONST, "2" )   # The pixel size is 2 bits per pixel.
	field( TWST, "4" )   # The pixel size is 4 bits per pixel.
	field( THST, "8" )   # The pixel size is 8 bits per pixel.
	field( FRST, "10" )  # The pixel size is 10 bits per pixel.
	field( FVST, "12" )  # The pixel size is 12 bits per pixel.
	field( SXST, "16" )  # The pixel size is 16 bits per pixel.
	field( SVST, "24" )  # The pixel size is 24 bits per pixel.
	field( EIST, "36" )  # The pixel size is 36 bits per pixel.
	field( NIST, "48" )  # The pixel size is 48 bits per pixel.
	field( FLNK, "$(P)$(R)PixelSize_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)PixelSize_RBV" )
{
	field( DESC, "Pixel Size readback value" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt64(\\x00,\\x03,\\x00,\\xA4) $(PORT).SER" )
	field( ZRVL,  1 )
	field( ONVL,  2 )
	field( TWVL,  4 )
	field( THVL,  8 )
	field( FRVL, 10 )
	field( FVVL, 12 )
	field( SXVL, 16 )
	field( SVVL, 24 )
	field( EIVL, 36 )
	field( NIVL, 48 )
	field( ZRST, "1" )   # The pixel size is 1 bit per pixel.
	field( ONST, "2" )   # The pixel size is 2 bits per pixel.
	field( TWST, "4" )   # The pixel size is 4 bits per pixel.
	field( THST, "8" )   # The pixel size is 8 bits per pixel.
	field( FRST, "10" )  # The pixel size is 10 bits per pixel.
	field( FVST, "12" )  # The pixel size is 12 bits per pixel.
	field( SXST, "16" )  # The pixel size is 16 bits per pixel.
	field( SVST, "24" )  # The pixel size is 24 bits per pixel.
	field( EIST, "36" )  # The pixel size is 36 bits per pixel.
	field( NIST, "48" )  # The pixel size is 48 bits per pixel.
#	field( PINI, "YES" )
}

record( longout, "$(P)$(R)BinningHorizontal" )
{
	field( DESC, "Horizontal binning" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x03,\\x03,\\x24) $(PORT).SER" )
	field( FLNK, "$(P)$(R)BinningHorizontal_RBV" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}

record( longin, "$(P)$(R)BinningHorizontal_RBV" )
{
	field( DESC, "Horizontal binning" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x03,\\x03,\\x24) $(PORT).SER" )
#	field( PINI, "YES" )
}

record( longout, "$(P)$(R)BinningVertical" )
{
	field( DESC, "Vertical binning" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x03,\\x03,\\x44) $(PORT).SER" )
	field( FLNK, "$(P)$(R)BinningVertical_RBV" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}

record( longin, "$(P)$(R)BinningVertical_RBV" )
{
	field( DESC, "Vertical binning" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x03,\\x03,\\x44) $(PORT).SER" )
#	field( PINI, "YES" )
}

# Not implemented
record( longout, "$(P)$(R)DecimationHorizontal" )
{
	field( DESC, "Horizontal decimation" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x03,\\x03,\\xA4) $(PORT).SER" )
	field( FLNK, "$(P)$(R)DecimationHorizontal_RBV" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
# Disabled to avoid accidental use
	field( DISV, "0" )
}

record( longin, "$(P)$(R)DecimationHorizontal_RBV" )
{
	field( DESC, "Horizontal decimation" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x03,\\x03,\\xA4) $(PORT).SER" )
}

record( longout, "$(P)$(R)DecimationVertical" )
{
	field( DESC, "Vertical decimation" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x03,\\x03,\\xC4) $(PORT).SER" )
	field( FLNK, "$(P)$(R)DecimationVertical_RBV" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}

record( longin, "$(P)$(R)DecimationVertical_RBV" )
{
	field( DESC, "Vertical decimation" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x03,\\x03,\\xC4) $(PORT).SER" )
#	field( PINI, "YES" )
}


# 4.5 Acquisition Control Registers

record( mbbo, "$(P)$(R)TrigModeAcqStart" )
{
	field( DESC, "Trigger Mode Acquisition Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x01,\\x04) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( ZRST, "OFF" )  # The trigger mode is set to off.
	field( ONST, "ON" )   # The trigger mode is set to on.
	field( FLNK, "$(P)$(R)TrigModeAcqStart_RBV" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)TrigModeAcqStart_RBV" )
{
	field( DESC, "Trigger Mode Acquisition Start" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x01,\\x04) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( ZRST, "OFF" )  # The trigger mode is set to off.
	field( ONST, "ON" )   # The trigger mode is set to on.
#	field( PINI, "YES" )
}

record( longout, "$(P)$(R)AcqFrameCount" )
{
	field( DOL,  "1" )
	field( DESC, "Acquisition Frame Count" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x00,\\xA4) $(PORT).SER" )
	field( HOPR,  127 )
	field( LOPR,  1   )
	field( FLNK, "$(P)$(R)AcqFrameCount_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( longin, "$(P)$(R)AcqFrameCount_RBV" )
{
	field( DESC, "Acquisition Frame Count" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x00,\\xA4) $(PORT).SER" )
}

record( mbbo, "$(P)$(R)TrigSrcAcqStart" )
{
	field( DESC, "Trigger Source Acquisition Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x01,\\x44) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( TWVL,  2 )
	field( THVL,  3 )
	field( FRVL,  4 )
	field( FVVL,  5 )
	field( SXVL,  6 )
	field( SVVL,  7 )
	field( EIVL,  8 )
	field( NIVL,  9 )
	field( TEVL, 10 )
	field( ELVL, 11 )
	field( TVVL, 12 )
	field( TTVL, 13 )
	field( FTVL, 14 )
	field( ZRST, "Software" )            # An internally generated software signal will be used as the trigger signal.
	field( ONST, "Line1" )               # A signal input into input line 1 will be used as the trigger signal.
	field( TWST, "Line2" )               # A signal input into input line 2 will be used as the trigger signal.
	field( THST, "Line3" )               # A signal input into input line 3 will be used as the trigger signal.
	field( FRST, "Line4" )               # A signal input into input line 4 will be used as the trigger signal.
	field( FVST, "Line5" )               # A signal input into input line 5 will be used as the trigger signal.
	field( SXST, "Line6" )               # A signal input into input line 6 will be used as the trigger signal.
	field( SVST, "Line7" )               # A signal input into input line 7 will be used as the trigger signal.
	field( EIST, "Line8" )               # A signal input into input line 8 will be used as the trigger signal.
	field( NIST, "CC1" )                 # A signal input into CC 1 in the Camera Link interface will be used as the trigger signal.
	field( TEST, "CC2" )                 # A signal input into CC 2 in the Camera Link interface will be used as the trigger signal.
	field( ELST, "CC3" )                 # A signal input into CC 3 in the Camera Link interface will be used as the trigger signal.
	field( TVST, "CC4" )                 # A signal input into CC 4 in the Camera Link interface will be used as the trigger signal.
	field( TTST, "ShaftEncoder" )        # A signal output from the shaft encoder module will be used as the trigger signal.
	field( FTST, "FrequencyConverter" )  # A signal output from the frequency converter module will be used as the trigger signal.
	field( FLNK, "$(P)$(R)TrigSrcAcqStart_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)TrigSrcAcqStart_RBV" )
{
	field( DESC, "Trigger Source Acquisition Start" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x01,\\x44) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( TWVL,  2 )
	field( THVL,  3 )
	field( FRVL,  4 )
	field( FVVL,  5 )
	field( SXVL,  6 )
	field( SVVL,  7 )
	field( EIVL,  8 )
	field( NIVL,  9 )
	field( TEVL, 10 )
	field( ELVL, 11 )
	field( TVVL, 12 )
	field( TTVL, 13 )
	field( FTVL, 14 )
	field( ZRST, "Software" )            # An internally generated software signal will be used as the trigger signal.
	field( ONST, "Line1" )               # A signal input into input line 1 will be used as the trigger signal.
	field( TWST, "Line2" )               # A signal input into input line 2 will be used as the trigger signal.
	field( THST, "Line3" )               # A signal input into input line 3 will be used as the trigger signal.
	field( FRST, "Line4" )               # A signal input into input line 4 will be used as the trigger signal.
	field( FVST, "Line5" )               # A signal input into input line 5 will be used as the trigger signal.
	field( SXST, "Line6" )               # A signal input into input line 6 will be used as the trigger signal.
	field( SVST, "Line7" )               # A signal input into input line 7 will be used as the trigger signal.
	field( EIST, "Line8" )               # A signal input into input line 8 will be used as the trigger signal.
	field( NIST, "CC1" )                 # A signal input into CC 1 in the Camera Link interface will be used as the trigger signal.
	field( TEST, "CC2" )                 # A signal input into CC 2 in the Camera Link interface will be used as the trigger signal.
	field( ELST, "CC3" )                 # A signal input into CC 3 in the Camera Link interface will be used as the trigger signal.
	field( TVST, "CC4" )                 # A signal input into CC 4 in the Camera Link interface will be used as the trigger signal.
	field( TTST, "ShaftEncoder" )        # A signal output from the shaft encoder module will be used as the trigger signal.
	field( FTST, "FrequencyConverter" )  # A signal output from the frequency converter module will be used as the trigger signal.
#	field( PINI, "YES" )
}

record( bo, "$(P)$(R)TrigSwAcqStart" )
{
	field( DESC, "Trigger Software Acquisition Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x01,\\x24) $(PORT).SER" )
	field( ZNAM, "OFF" )
	field( ONAM, "ON"  )
}

record( mbbo, "$(P)$(R)TrigActAcqStart" )
{
	field( DESC, "Trigger Activation Acquisition Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x01,\\x64) $(PORT).SER" )
	field( DOL,  0 )
	field( ZRVL, 0 )
	field( ONVL, 1 )
	field( TWVL, 2 )
	field( THVL, 3 )
	field( FRVL, 4 )
	field( ZRST, "RisingEdge" )   # The trigger signal is considered valid on the rising edge of the signal.
	field( ONST, "FallingEdge" )  # The trigger signal is considered valid on the falling edge of the signal.
	field( TWST, "AnyEdge" )      # The trigger signal is considered valid both on the rising edge and on the falling edge of the signal.
	field( THST, "LevelHigh" )    # The trigger signal is considered valid as long as it is high.
	field( FRST, "LevelLow" )     # The trigger signal is considered valid as long as it is low.
	field( FLNK, "$(P)$(R)TrigActAcqStart_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)TrigActAcqStart_RBV" )
{
	field( DESC, "Trigger Activation Acquisition Start" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x01,\\x64) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 1 )
	field( TWVL, 2 )
	field( THVL, 3 )
	field( FRVL, 4 )
	field( ZRST, "RisingEdge" )   # The trigger signal is considered valid on the rising edge of the signal.
	field( ONST, "FallingEdge" )  # The trigger signal is considered valid on the falling edge of the signal.
	field( TWST, "AnyEdge" )      # The trigger signal is considered valid both on the rising edge and on the falling edge of the signal.
	field( THST, "LevelHigh" )    # The trigger signal is considered valid as long as it is high.
	field( FRST, "LevelLow" )     # The trigger signal is considered valid as long as it is low.
#	field( PINI, "YES" )
}

record( longout, "$(P)$(R)TrigDelayRawAcqStart" )
{
	field( DESC, "Trigger Delay Raw Acquisition Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x01,\\x84) $(PORT).SER" )
}

record( longin, "$(P)$(R)StatAcqTrigWait" )
{
	field( DESC, "Status Acquisition Trigger Wait" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x06,\\x08) $(PORT).SER" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbo, "$(P)$(R)TrigModeFrameStart" )
{
	field( DOL,  "1" )
	field( DESC, "Trigger Mode Frame Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x02,\\x04) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( ZRST, "OFF" )  # The trigger mode is set to off.
	field( ONST, "ON" )   # The trigger mode is set to on.
	field( FLNK, "$(P)$(R)TrigModeFrameStart_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)TrigModeFrameStart_RBV" )
{
	field( DESC, "Trigger Mode Frame Start readback value" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x02,\\x04) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( ZRST, "OFF" )  # The trigger mode is set to off.
	field( ONST, "ON" )   # The trigger mode is set to on.
}

record( mbbo, "$(P)$(R)TrigSrcFrameStart" )
{
	field( DOL,  "9" )
	field( DESC, "Trigger Source Frame Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x02,\\x44) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( TWVL,  2 )
	field( THVL,  3 )
	field( FRVL,  4 )
	field( FVVL,  5 )
	field( SXVL,  6 )
	field( SVVL,  7 )
	field( EIVL,  8 )
	field( NIVL,  9 )
	field( TEVL, 10 )
	field( ELVL, 11 )
	field( TVVL, 12 )
	field( TTVL, 13 )
	field( FTVL, 14 )
	field( ZRST, "Software" )            # An internally generated software signal will be used as the trigger signal.
	field( ONST, "Line1" )               # A signal input into input line 1 will be used as the trigger signal.
	field( TWST, "Line2" )               # A signal input into input line 2 will be used as the trigger signal.
	field( THST, "Line3" )               # A signal input into input line 3 will be used as the trigger signal.
	field( FRST, "Line4" )               # A signal input into input line 4 will be used as the trigger signal.
	field( FVST, "Line5" )               # A signal input into input line 5 will be used as the trigger signal.
	field( SXST, "Line6" )               # A signal input into input line 6 will be used as the trigger signal.
	field( SVST, "Line7" )               # A signal input into input line 7 will be used as the trigger signal.
	field( EIST, "Line8" )               # A signal input into input line 8 will be used as the trigger signal.
	field( NIST, "CC1" )                 # A signal input into CC 1 in the Camera Link interface will be used as the trigger signal.
	field( TEST, "CC2" )                 # A signal input into CC 2 in the Camera Link interface will be used as the trigger signal.
	field( ELST, "CC3" )                 # A signal input into CC 3 in the Camera Link interface will be used as the trigger signal.
	field( TVST, "CC4" )                 # A signal input into CC 4 in the Camera Link interface will be used as the trigger signal.
	field( TTST, "ShaftEncoder" )        # A signal output from the shaft encoder module will be used as the trigger signal.
	field( FTST, "FrequencyConverter" )  # A signal output from the frequency converter module will be used as the trigger signal.
	field( FLNK, "$(P)$(R)TrigSrcFrameStart_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)TrigSrcFrameStart_RBV" )
{
	field( DESC, "Trigger Source Frame Start readback" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x02,\\x44) $(PORT).SER" )
	field( ZRVL,  0 )
	field( ONVL,  1 )
	field( TWVL,  2 )
	field( THVL,  3 )
	field( FRVL,  4 )
	field( FVVL,  5 )
	field( SXVL,  6 )
	field( SVVL,  7 )
	field( EIVL,  8 )
	field( NIVL,  9 )
	field( TEVL, 10 )
	field( ELVL, 11 )
	field( TVVL, 12 )
	field( TTVL, 13 )
	field( FTVL, 14 )
	field( ZRST, "Software" )            # An internally generated software signal will be used as the trigger signal.
	field( ONST, "Line1" )               # A signal input into input line 1 will be used as the trigger signal.
	field( TWST, "Line2" )               # A signal input into input line 2 will be used as the trigger signal.
	field( THST, "Line3" )               # A signal input into input line 3 will be used as the trigger signal.
	field( FRST, "Line4" )               # A signal input into input line 4 will be used as the trigger signal.
	field( FVST, "Line5" )               # A signal input into input line 5 will be used as the trigger signal.
	field( SXST, "Line6" )               # A signal input into input line 6 will be used as the trigger signal.
	field( SVST, "Line7" )               # A signal input into input line 7 will be used as the trigger signal.
	field( EIST, "Line8" )               # A signal input into input line 8 will be used as the trigger signal.
	field( NIST, "CC1" )                 # A signal input into CC 1 in the Camera Link interface will be used as the trigger signal.
	field( TEST, "CC2" )                 # A signal input into CC 2 in the Camera Link interface will be used as the trigger signal.
	field( ELST, "CC3" )                 # A signal input into CC 3 in the Camera Link interface will be used as the trigger signal.
	field( TVST, "CC4" )                 # A signal input into CC 4 in the Camera Link interface will be used as the trigger signal.
	field( TTST, "ShaftEncoder" )        # A signal output from the shaft encoder module will be used as the trigger signal.
	field( FTST, "FrequencyConverter" )  # A signal output from the frequency converter module will be used as the trigger signal.
}

record( bo, "$(P)$(R)TrigSwFrameStart" )
{
	field( DOL,  "0" )
	field( DESC, "Trigger Software Frame Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x02,\\x24) $(PORT).SER" )
	field( ZNAM, "OFF" )
	field( ONAM, "ON"  )
	field( FLNK, "$(P)$(R)TrigSwFrameStart_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( bi, "$(P)$(R)TrigSwFrameStart_RBV" )
{
	field( DESC, "Trigger Software Frame Start" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x02,\\x24) $(PORT).SER" )
	field( ZNAM, "OFF" )
	field( ONAM, "ON"  )
}

record( mbbo, "$(P)$(R)TrigActFrameStart" )
{
	field( DOL,  "0" )
	field( DESC, "Trigger Activation Frame Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x02,\\x64) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 1 )
	field( TWVL, 2 )
	field( THVL, 3 )
	field( FRVL, 4 )
	field( ZRST, "RisingEdge" )   # The trigger signal is considered valid on the rising edge of the signal.
	field( ONST, "FallingEdge" )  # The trigger signal is considered valid on the falling edge of the signal.
	field( TWST, "AnyEdge" )      # The trigger signal is considered valid both on the rising edge and on the falling edge of the signal.
	field( THST, "LevelHigh" )    # The trigger signal is considered valid as long as it is high.
	field( FRST, "LevelLow" )     # The trigger signal is considered valid as long as it is low.
	field( FLNK, "$(P)$(R)TrigActFrameStart_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)TrigActFrameStart_RBV" )
{
	field( DESC, "Trigger Activation Frame Start readback" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x02,\\x64) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 1 )
	field( TWVL, 2 )
	field( THVL, 3 )
	field( FRVL, 4 )
	field( ZRST, "RisingEdge" )   # The trigger signal is considered valid on the rising edge of the signal.
	field( ONST, "FallingEdge" )  # The trigger signal is considered valid on the falling edge of the signal.
	field( TWST, "AnyEdge" )      # The trigger signal is considered valid both on the rising edge and on the falling edge of the signal.
	field( THST, "LevelHigh" )    # The trigger signal is considered valid as long as it is high.
	field( FRST, "LevelLow" )     # The trigger signal is considered valid as long as it is low.
}

record( longout, "$(P)$(R)TrigDelayRawFrameStart" )
{
	field( DESC, "Trigger Delay Raw Frame Start" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x02,\\x84) $(PORT).SER" )
}

record( longin, "$(P)$(R)StatFrameTrigWait" )
{
	field( DESC, "Status Frame Trigger Wait" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x06,\\x68) $(PORT).SER" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}

record( longout, "$(P)$(R)ExposureOverlapTimeMaxRaw" )
{
	field( DESC, "Exposure Overlap Time Max Raw" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\xE0,\\x04) $(PORT).SER" )
}

record( longin, "$(P)$(R)ReadoutTimeRaw" )
{
	field( DESC, "Readout Time Raw" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\xE0,\\x28) $(PORT).SER" )
#	field( SCAN, "Passive" )
#	field( PINI, "YES" )
}


# 4.6 Exposure Control Registers

record( mbbo, "$(P)$(R)CamTriggerMode" )
{
	field( FLNK, "$(P)$(R)BaslerCalcExposureMode" )
}

record( calc, "$(P)$(R)BaslerCalcExposureMode" )
{
#	field( TPRO, 2 )
	field( DESC, "Maps ADTriggerMode to BaslerExposureMode" )
	field( INPA, "$(P)$(R)CamTriggerMode NPP NMS" )
	field( CALC, "A==2?2:1" )
	field( FLNK, "$(P)$(R)BaslerExposureMode" )
}

record( mbbo, "$(P)$(R)BaslerExposureMode" )
{
	field( DESC, "Exposure Mode" )
	field( DTYP, "stream" )
	field( OMSL, "closed_loop" )
#	field( DOL,  "$(P)$(R)BaslerCalcExposureMode NPP NMS" )
	field( DOL,  "2" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x04,\\x04) $(PORT).SER" )
	field( ZRVL, "0" )
	field( ONVL, "1" )
	field( TWVL, "2" )
	field( ZRST, "Off" )           # The exposure is disabled.
	field( ONST, "Timed" )         # The exposure mode is timed.
	field( TWST, "TriggerWidth" )  # The exposure mode is trigger width.
	field( FLNK, "$(P)$(R)BaslerExposureMode_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)BaslerExposureMode_RBV" )
{
	field( DESC, "Exposure Mode readback value" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x04,\\x04) $(PORT).SER" )
	field( ZRVL, "0" )
	field( ONVL, "1" )
	field( TWVL, "2" )
	field( ZRST, "Off" )           # The exposure is disabled.
	field( ONST, "Timed" )         # The exposure mode is timed.
	field( TWST, "TriggerWidth" )  # The exposure mode is trigger width.
	field( FLNK, "$(P)$(R)BaslerCalcCamTriggerMode" )
}

record( calcout, "$(P)$(R)BaslerCalcCamTriggerMode" )
{
#	field( TPRO, 2 )
	field( DESC, "Map BaslerExposureMode to TriggerMode" )
	field( INPA, "$(P)$(R)BaslerExposureMode_RBV NPP NMS" )
	field( INPB, "$(P)$(R)CamTriggerMode NPP NMS" )
	field( CALC, "A==2?2:(B==0?0:1)" )
	field( OUT,  "$(P)$(R)CamTriggerMode_RBV CA MS" )
}

# CamTriggerMode_RBV gets it's value from BaslerCalcCamTriggerMode
record( mbbi, "$(P)$(R)CamTriggerMode_RBV" )
{
#	field( TPRO, 2 )
}

record( longout, "$(P)$(R)ExposureTimeRaw" )
{
	field( DOL,  "100" )
	field( DESC, "Exposure Time Raw" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x04,\\x64) $(PORT).SER" )
	field( FLNK, "$(P)$(R)ExposureTimeRaw_RBV" )
}

record( longin, "$(P)$(R)ExposureTimeRaw_RBV" )
{
	field( DESC, "Exposure Time Raw" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x04,\\x64) $(PORT).SER" )
#	field( PINI, "YES" )
}

record( longin, "$(P)$(R)StatusExposureActive" )
{
	field( DESC, "Status Exposure Active" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x06,\\xC8) $(PORT).SER" )
}


# 4.7 Time Base Register

record( longin, "$(P)$(R)BaslerTimeBase_RBV" )
{
	field( DESC, "TimeBase for delays and exposure" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x04,\\x48) $(PORT).SER" )
	field( EGU,  "ns"  )
#	field( PINI, "YES" )
}


# 4.8 Frame Period Registers

record( bo, "$(P)$(R)AcqFramePeriodEnable" )
{
	field( DESC, "Acquisition Frame Period Enable" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x04,\\x84) $(PORT).SER" )
	field( ZNAM, "OFF" )
	field( ONAM, "ON"  )
	field( FLNK, "$(P)$(R)AcqFramePeriodEnable_RBV" )
}

record( bi, "$(P)$(R)AcqFramePeriodEnable_RBV" )
{
	field( DESC, "Acquisition Frame Period Enable" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x04,\\x84) $(PORT).SER" )
	field( ZNAM, "OFF" )
	field( ONAM, "ON"  )
#	field( PINI, "YES" )
}

record( longout, "$(P)$(R)AcqFramePeriodRaw" )
{
	field( DOL,  "100" )
	field( DESC, "Acquisition Frame Period Raw" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x04,\\xA4) $(PORT).SER" )
	field( HOPR,  0x3ffffff )
	field( LOPR,  1         )
	field( FLNK, "$(P)$(R)AcqFramePeriodRaw_RBV" )
}

record( longin, "$(P)$(R)AcqFramePeriodRaw_RBV" )
{
	field( DESC, "Acquisition Frame Period Raw" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x04,\\xA4) $(PORT).SER" )
}

record( ao, "$(P)$(R)AcquirePeriod"  )
{
	field( DISA, "0" )
	field( FLNK, "$(P)$(R)BaslerCalcAcquirePeriod" )
	field( PINI, "YES" )
	info( autosaveFields, "PREC VAL" )
	info( archiveFields,  "PREC VAL" )
}

# Max of 0x? from 0x? RegFixedIntervalMax
# Min of 0x? from 0x? RegFixedIntervalLimit
record( calcout, "$(P)$(R)BaslerCalcAcquirePeriod" )
{
	field( INPA, "$(P)$(R)AcquirePeriod" )
	field( INPB, "$(P)$(R)BaslerTimeBase_RBV CPP NMS" )
	field( CALC, "B?A/B:1" )
	field( FLNK, "$(P)$(R)BaslerAcquirePeriod" )
#	field( HOPR,  0x6666666 )
#	field( LOPR,  7017      )
	field( EGU,  "us"       )
}

# Set the acquire period, the rep rate for image capture
# Argument is an integer in us
record( longout, "$(P)$(R)BaslerAcquirePeriod" )
{
	field( DESC, "Set The Frame Period" )
	field( OMSL, "closed_loop" )
	field( DOL,  "$(P)$(R)BaslerCalcAcquirePeriod NPP NMS" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x04,\\xA4) $(PORT).SER" )
	field( FLNK, "$(P)$(R)BaslerAcquirePeriod_RBV" )
#	field( HOPR,  0x6666666 )
#	field( LOPR,  7017      )
	field( EGU,  "us"    )
}

# Read AcquirePeriod, the rep rate for image capture
# Only relevant in FreeRun trigger mode
# Reply value is an integer in us
record( longin, "$(P)$(R)BaslerAcquirePeriod_RBV" )
{
	field( DESC, "Frame Period" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x04,\\xA4) $(PORT).SER" )
	field( EGU,  "us"  )
	field( FLNK, "$(P)$(R)BaslerCalcAcquirePeriod_RBV"  )
}

record( calcout, "$(P)$(R)BaslerCalcAcquirePeriod_RBV" )
{
	field( INPA, "$(P)$(R)BaslerAcquirePeriod_RBV"  )
	field( INPB, "1e-6" )
	field( CALC, "A*B" )
	field( EGU,  "sec"  )
	field( OUT,  "$(P)$(R)AcquirePeriod_RBV PP MS"  )
}
record( ai, "$(P)$(R)AcquirePeriod_RBV"    )
{
	field( DISA, "0" )
}

record( longin, "$(P)$(R)ResFramePeriodRaw" )
{
	field( DESC, "Resulting Frame Period Raw" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x05,\\x08) $(PORT).SER" )
}

# Not implemented
record( longout, "$(P)$(R)AcqLinePeriodRaw" )
{
	field( DESC, "Acquisition Line Period Raw" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x04,\\x05,\\x24) $(PORT).SER" )
	field( FLNK, "$(P)$(R)AcqLinePeriodRaw_RBV" )
}

record( longin, "$(P)$(R)AcqLinePeriodRaw_RBV" )
{
	field( DESC, "Acquisition Line Period Raw" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x04,\\x05,\\x24) $(PORT).SER" )
#	field( PINI, "YES" )
}


# 4.9 Sequencer Control Registers
# TBC

# -----

record( longout, "$(P)$(R)BaslerBlackLevel" )
{
	field( DESC, "Set The Black Level" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x02,\\x02,\\x04) $(PORT).SER" )
	field( HOPR, 4096 )
	field( DRVH, 4096 )
	field( LOPR, 0    )
	field( DRVL, 0    )
	info( autosaveFields, "DESC VAL" )
	field( FLNK, "$(P)$(R)BaslerBlackLevel_RBV" )
	field( SCAN, "Passive" )
	field( PINI, "YES" )
}

record( longin, "$(P)$(R)BaslerBlackLevel_RBV" )
{
	field( DESC, "Black Level" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x02,\\x02,\\x04) $(PORT).SER" )
	field( PINI, "YES" )
}

record( mbbo, "$(P)$(R)BaslerTestPattern" )
{
	field( DOL,  "0" )
	field( DESC, "Test Image Selector" )
	field( DTYP, "stream" )
	field( OUT,  "@Basler.proto SetUInt32(\\x00,\\x03,\\x01,\\x64) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 1 )
	field( TWVL, 2 )
	field( THVL, 3 )
	field( FRVL, 4 )
	field( FVVL, 5 )
	field( ZRST, "Off" )         # The test image function is off and the camera will operate normally.
	field( ONST, "8BitFixed" )   # 8  Bit Fixed  Diaganol Gray Gradient
	field( TWST, "8BitMoving" )  # 8  Bit Moving Diaganol Gray Gradient
	field( THST, "12BitMoving" ) # 12 Bit Moving Diaganol Gray Gradient
	field( FRST, "8BitProc" )    # 8  Bit Moving Diaganol Gray Gradient w/ digital processing features
	field( FVST, "12BitProc" )   # 12 Bit Moving Diaganol Gray Gradient w/ digital processing features
	field( FLNK, "$(P)$(R)BaslerTestPattern_RBV" )
	field( PINI, "YES" )
}

record( mbbi, "$(P)$(R)BaslerTestPattern_RBV" )
{
	field( DESC, "The Test Image Selector" )
	field( DTYP, "stream" )
	field( INP,  "@Basler.proto GetUInt32(\\x00,\\x03,\\x01,\\x64) $(PORT).SER" )
	field( ZRVL, 0 )
	field( ONVL, 1 )
	field( TWVL, 2 )
	field( THVL, 3 )
	field( FRVL, 4 )
	field( FVVL, 5 )
	field( ZRST, "Off" )         # The test image function is off and the camera will operate normally.
	field( ONST, "8BitFixed" )   # 8  Bit Fixed  Diaganol Gray Gradient
	field( TWST, "8BitMoving" )  # 8  Bit Moving Diaganol Gray Gradient
	field( THST, "12BitMoving" ) # 12 Bit Moving Diaganol Gray Gradient
	field( FRST, "8BitProc" )    # 8  Bit Moving Diaganol Gray Gradient w/ digital processing features
	field( FVST, "12BitProc" )   # 12 Bit Moving Diaganol Gray Gradient w/ digital processing features
}

## Something about the following causes LastUserError to go to InvalidParameter
## Only way out that I've found is to power cycle the camera
substitute "SER_OK_PV=$(PGP):Ch$(PGP_LANE):PgpMon:RxRemLinkReady_RBV"
substitute "MON_PV=$(P)$(R)Manufacturer_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)Model_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerFirmwareVersion_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerVersion_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerSerialNumber_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerModel_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerTestPattern_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)CamlinkHTap"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerTimeBase_RBV"
#include "rbvMonitor.template"

substitute "MON_PV=$(P)$(R)BaslerExposureMode"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigModeFrameStart"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSrcFrameStart"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigActFrameStart"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSwFrameStart"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigModeAcqStart"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSrcAcqStart"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigActAcqStart"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSwAcqStart"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerBlackLevel"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerBitsPerPixel"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerCLConfig"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)CLBaudRate"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)CLPixelClock"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)PixelFormat"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)PixelSize"
include "putMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerExposureMode"
#include "putMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerAcquirePeriod"
#include "putMonitor.template"

# Temp hack while putMonitor PVs are disabled
# Add rbvMonitor for these PVs which would otherwise get reread when putMonitor sets the value
substitute "MON_PV=$(P)$(R)BaslerExposureMode_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigModeFrameStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSrcFrameStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigActFrameStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSwFrameStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigModeAcqStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSrcAcqStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigActAcqStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)TrigSwAcqStart_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerBlackLevel_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerBitsPerPixel_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerCLConfig_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)CLBaudRate_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)CLPixelClock_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)PixelFormat_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerExposureMode_RBV"
include "rbvMonitor.template"
substitute "MON_PV=$(P)$(R)BaslerAcquirePeriod_RBV"
include "rbvMonitor.template"
